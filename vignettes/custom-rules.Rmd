---
title: "Custom Rules in Practice"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Custom Rules in Practice}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment  = "#>",
  eval     = FALSE
)
```

# Customizing the Rule Engine

`sdtmbuilder` applies one rule per target variable via `compile_rules()`. The
default behaviour auto-assigns rules from the **Study_Metadata.xlsx** Variables
sheet, but every rule can be extended, overridden, or replaced.

## 1 Where Rules Come From

```{r}
library(sdtmbuilder)

# ── Read metadata ────────────────────────────────────
meta <- read_study_metadata_excel("inst/extdata/Study_Metadata.xlsx")
ct   <- read_study_ct_excel("inst/extdata/Study_CT.xlsx")

target_meta <- meta$target_meta
ct_lib      <- ct$ct_lib

# ── Compile rules (auto-assigns rule_type for METHOD=NA) ─
rule_set <- compile_rules(target_meta, ct_lib = ct_lib)
```

`compile_rules()` examines the `METHOD` column in `target_meta`:

| METHOD value | Resulting `rule_type` | Parameters |
|---|---|---|
| `NA` | `"direct_map"` | `dataset = "{domain}_raw"`, `column = "{var_lower}"` |
| `"constant"` | `"constant"` | `value = ""` (override with VALUE column) |
| `"STUDYID"` | `"constant"` | auto-filled from config |
| `"DOMAIN"` | `"constant"` | auto-filled |
| explicit JSON | as declared | parsed from JSON string |

## 2 Overriding a Rule via the Excel Metadata

The easiest way to customize a rule is editing the **Variables** sheet in
`Study_Metadata.xlsx`. Set the `METHOD` column to a JSON string:

| DOMAIN | VARIABLE | METHOD |
|--------|----------|--------|
| AE | AESEV | `{"rule_type": "assign_ct", "params": {"codelist": "SEV", "dataset": "ae_raw", "column": "severity"}}` |

When `compile_rules()` encounters a JSON string in METHOD, it parses it
directly as the rule definition.

## 3 Overriding a Rule Programmatically

After compilation, rules can be patched in-place:

```{r}
# Replace a specific variable rule
rule_set$rules$AE$AESEV <- list(
  rule_type = "assign_ct",
  params    = list(codelist = "SEV", dataset = "ae_raw", column = "severity"),
  deps      = character()
)
```

## 4 Adding a Fully Custom Derivation

For logic that doesn't fit any built-in `rule_type`, use `"custom"`:

```{r}
rule_set$rules$AE$AEOUT <- list(
  rule_type = "custom",
  params    = list(
    fn = function(row_df, ctx) {
      dplyr::case_when(
        ctx$AEONGO == "Y" ~ "NOT RECOVERED/NOT RESOLVED",
        ctx$AESEV  == "MILD" ~ "RECOVERED/RESOLVED",
        TRUE ~ "UNKNOWN"
      )
    }
  ),
  deps = c("AEONGO", "AESEV")
)
```

The function receives:

- `row_df` — the assembled records so far (all source columns merged)
- `ctx` — a list containing previously derived variables for that domain

## 5 Controlling Derivation Order

When you add inter-variable dependencies (e.g., `AEOUT` depends on `AESEV`),
`build_dependency_graph()` resolves the topological order:

```{r}
g <- build_dependency_graph(rule_set, domain = "AE")
topo <- topo_sort_rules(g)
topo
# [1] "STUDYID" "DOMAIN" "USUBJID" "AETERM" "AEDECOD"
# [6] "AESEV"   "AESERP"  "AEOUT"   "AESTDTC" "AEENDTC"
# [11] "AEDY"   "AESEQ"
```

Variables with explicit `deps` are placed after their dependencies.

## 6 Working with Study_CT.xlsx

Controlled-terminology rules rely on codelists defined in **Study_CT.xlsx**:

```{r}
ct <- read_study_ct_excel("inst/extdata/Study_CT.xlsx")
ct$ct_lib
#> # A tibble: 16 × 4
#>    CODELIST_CODE TERM_CODE  TERM_DECODE         CODELIST_NAME
#>    <chr>         <chr>      <chr>               <chr>
#>  1 YN            Y          Yes                 Yes / No
#>  2 YN            N          No                  Yes / No
#>  3 LBTESTCD      ALB        Albumin             Lab Test Code
#>  4 LBTESTCD      GLUC       Glucose             Lab Test Code
#>  …
```

Add new codelists by editing the **CT_Terms** sheet in Study_CT.xlsx.

## 7 Full Domain Build with Custom Rules

```{r}
config   <- new_sdtm_config(studyid = "STUDY01")
raw_data <- load_raw_datasets("raw")

# Apply customizations
rule_set$rules$AE$AESEV$params$column <- "ae_severity"

result <- build_domain(
  domain      = "AE",
  target_meta = target_meta,
  raw_data    = raw_data,
  config      = config,
  rule_set    = rule_set
)

head(result$data)
```

## 8 Tips

- **Start simple**: let `compile_rules()` auto-assign defaults, then override
  only the variables that need special logic.
- **Use JSON in METHOD**: for rules that can be expressed declaratively, JSON in
  the Excel metadata is the most maintainable approach.
- **Reserve `"custom"`**: for complex multi-variable derivations that need
  R function logic.
- **Test incrementally**: build one domain at a time with `build_domain()` before
  running `build_all_domains()`.
