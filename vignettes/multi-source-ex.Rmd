---
title: "Multi-Source Domain Building"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Multi-Source Domain Building}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment  = "#>",
  eval     = FALSE
)
```

# Building a Domain from Multiple Source Datasets

Some SDTM domains draw data from more than one source. For example, **CM**
(Concomitant Medications) might pull from both a medication log and a prior
medication history.

## Scenario

Raw data directory contains:

- `cm_raw.csv` — protocol medication log
- `cm_prior.csv` — pre-study medication history

Both should map into the CM domain.

## Step-by-Step

```{r}
library(sdtmbuilder)

# ── 1. Metadata ──────────────────────────────────────
meta <- read_study_metadata_excel("inst/extdata/Study_Metadata.xlsx")
ct   <- read_study_ct_excel("inst/extdata/Study_CT.xlsx")

target_meta <- meta$target_meta
ct_lib      <- ct$ct_lib

# ── 2. Configuration ────────────────────────────────
config <- new_sdtm_config(study_id = "STUDY01")

# ── 3. Load raw data ────────────────────────────────
raw_data <- load_raw_data(config)
# raw_data$cm_raw   — the main medication log
# raw_data$cm_prior — the prior medication history

# ── 4. Compile rules (auto-assigned from metadata) ──
rule_set <- compile_rules(target_meta, ct_lib = ct_lib)
```

### Merging Sources with `bind_sources()`

When two source datasets share the same column structure, use
`bind_sources()` before building:

```{r}
# Stack both CM sources into one combined dataset
raw_data$cm_raw <- bind_sources(
  primary   = raw_data$cm_raw,
  secondary = raw_data$cm_prior,
  domain    = "CM",
  add_provenance = TRUE
)
```

`bind_sources()` will:
- Align columns by name
- Fill missing columns with NA
- Add optional `SRC_DATASET` provenance column

### Building the Domain

```{r}
result <- build_domain(
  domain      = "CM",
  target_meta = target_meta,
  raw_data    = raw_data,
  config      = config,
  rule_set    = rule_set
)

head(result$data)
```

## Multiple Sources with Different Column Structures

If the secondary source has different column names, map them in the rules via
JSON in the METHOD column of `Study_Metadata.xlsx`:

```json
{
  "rule_type": "coalesce",
  "params": {
    "sources": [
      {"dataset": "cm_raw",   "column": "med_name"},
      {"dataset": "cm_prior", "column": "medication"}
    ]
  }
}
```

Or override programmatically:

```{r}
rule_set$rules$CM$CMTRT <- list(
  rule_type = "coalesce",
  params    = list(
    sources = list(
      list(dataset = "cm_raw",   column = "med_name"),
      list(dataset = "cm_prior", column = "medication")
    )
  ),
  deps = character()
)
```

## Using `build_domain_from_sources()`

For more control, `build_domain_from_sources()` lets you pass a named list
of source data frames directly:

```{r}
result <- build_domain_from_sources(
  domain      = "CM",
  target_meta = target_meta,
  sources     = list(
    cm_raw   = raw_data$cm_raw,
    cm_prior = raw_data$cm_prior
  ),
  config      = config,
  rule_set    = rule_set
)

head(result$data)
```

This bypasses the default `{domain}_raw` dataset lookup convention and
gives you full control over which datasets participate.
